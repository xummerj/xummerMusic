package com.zmxv.RNSound;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.modules.core.DeviceEventManagerModule;

import android.media.AudioManager;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnCompletionListener;
import android.media.MediaPlayer.OnErrorListener;
import android.media.audiofx.Visualizer;
import android.support.annotation.Nullable;
import android.util.Log;
import android.widget.Toast;

public class RNSoundModule extends ReactContextBaseJavaModule {
  Map<Integer, MediaPlayer> playerPool = new HashMap<>();
  ReactApplicationContext context;
  final static Object NULL = null;
  private Visualizer mVisualizer;

  public RNSoundModule(ReactApplicationContext context) {
    super(context);
    this.context = context;
  }

  @Override
  public String getName() {
    return "RNSound";
  }


  @ReactMethod
  public void prepare(final String fileName, final Integer key, final Callback callback) {
    int res = this.context.getResources().getIdentifier(fileName, "raw", this.context.getPackageName());
    MediaPlayer player;
    if (res != 0) {
        player = MediaPlayer.create(this.context, res);
    }else{
        File file = new File(fileName);
        if (!file.exists() && !fileName.startsWith("http")) {
          WritableMap e = Arguments.createMap();
          e.putInt("code", -1);
          e.putString("message", "resource not found");
          callback.invoke(e);
          return;
        }else{
          try{
            player = new MediaPlayer();
            player.setAudioStreamType(AudioManager.STREAM_MUSIC);
            player.setDataSource(fileName);
           // player.setDataSource(fileName);

            player.prepare();
          }catch (IOException err) {
            WritableMap e = Arguments.createMap();
            e.putInt("code", -1);
            e.putString("message", err.getMessage());
            callback.invoke(e);
            return;
          }
        }
    }
    this.playerPool.put(key, player);
    WritableMap props = Arguments.createMap();
    props.putDouble("duration", player.getDuration() * .001);
    callback.invoke(NULL, props);


  }

  private void sendEvent(ReactContext reactContext, String eventName,  @Nullable WritableMap params) {
    reactContext
            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
            .emit(eventName, params);
  }
  @ReactMethod
  public void play(final Integer key, final Callback callback) {
    MediaPlayer player = this.playerPool.get(key);


    if (player == null) {
      callback.invoke(false);
      return;
    }

    if (player.isPlaying()) {
      return;
    }
    player.setOnCompletionListener(new OnCompletionListener() {
      @Override
      public void onCompletion(MediaPlayer mp) {
        if (!mp.isLooping()) {
          mVisualizer.setEnabled(false);
          callback.invoke(true);
        }
      }
    });
    player.setOnErrorListener(new OnErrorListener() {
      @Override
      public boolean onError(MediaPlayer mp, int what, int extra) {
        callback.invoke(false);
        return true;
      }
    });
    player.start();

    mVisualizer = new Visualizer(player.getAudioSessionId());
    mVisualizer.setCaptureSize(Visualizer.getCaptureSizeRange()[1]);
    mVisualizer.setDataCaptureListener(new Visualizer.OnDataCaptureListener() {
      //这个回调应该采集的是波形数据
      @Override
      public void onWaveFormDataCapture(Visualizer visualizer, byte[] waveform,
                                        int samplingRate) {
        //waveformView 是一个自定义的view用来按照波形来画图 一会后面再讲
        int[] waveValue = new int[waveform.length];
        for (int i = 0; i < waveform.length; i++) {
          waveValue[i] = waveform[i];
        }
        //Log.e("xummer", String.valueOf(waveform.length));
        WritableMap data = Arguments.createMap();
        data.putArray("waveform", Arguments.fromArray(waveValue));
        sendEvent(context, "MusicVisualizer", data);
      }

      //这个回调应该采集的是快速傅里叶变换有关的数据，没试过，回头有空了再试试
      @Override
      public void onFftDataCapture(Visualizer visualizer, byte[] fft,
                                   int samplingRate) {

        int[] model = new int[101];
        model[0] = (byte) Math.abs(fft[1]);
        int j = 1;
        for (int i = 2; i < 100; ) {
          model[j] = (byte) Math.hypot(fft[i], fft[i + 1]);
          i += 2;
          j++;
        }
        WritableMap data = Arguments.createMap();
        data.putArray("waveform", Arguments.fromArray(model));
        sendEvent(context, "MusicVisualizer", data);
//        Log.e("xummer", String.valueOf(Visualizer.getMaxCaptureRate() / 2));
//        Log.e("xummer", String.valueOf(fft.length));
      }
    }, Visualizer.getMaxCaptureRate() / 2, false, true);

    mVisualizer.setEnabled(true);
  }

  @ReactMethod
  public void pause(final Integer key) {
    MediaPlayer player = this.playerPool.get(key);
    if (player != null && player.isPlaying()) {
      player.pause();
    }
  }

  @ReactMethod
  public void stop(final Integer key) {
    MediaPlayer player = this.playerPool.get(key);
    if (player != null && player.isPlaying()) {
      player.stop();
      mVisualizer.setEnabled(false);
      try {
        player.prepare();
      } catch (Exception e) {
      }
    }
  }

  @ReactMethod
  public void release(final Integer key) {
    MediaPlayer player = this.playerPool.get(key);
    if (player != null) {
      player.release();
      mVisualizer.setEnabled(false);
      this.playerPool.remove(key);
    }
  }

  @ReactMethod
  public void setVolume(final Integer key, final Float left, final Float right) {
    MediaPlayer player = this.playerPool.get(key);
    if (player != null) {
      player.setVolume(left, right);
    }
  }

  @ReactMethod
  public void setLooping(final Integer key, final Boolean looping) {
    MediaPlayer player = this.playerPool.get(key);
    if (player != null) {
      player.setLooping(looping);
    }
  }

  @ReactMethod
  public void setCurrentTime(final Integer key, final Float sec) {
    MediaPlayer player = this.playerPool.get(key);
    if (player != null) {
      player.seekTo((int)Math.round(sec * 1000));
    }
  }

  @ReactMethod
  public void getCurrentTime(final Integer key, final Callback callback) {
    MediaPlayer player = this.playerPool.get(key);
    if (player == null) {
      callback.invoke(-1, false);
      return;
    }
    callback.invoke(player.getCurrentPosition() * .001, player.isPlaying());
  }
}
